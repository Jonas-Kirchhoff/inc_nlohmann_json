
### WFJ-01 

The service checks the well-formedness of the literal names.


**Supported Requests:**

- [JLEX-01](JLEX.md#jlex-01)

**Supporting Items:**

- [NJF-02](NJF.md#njf-02)
- [NJF-03](NJF.md#njf-03)
- [NJF-04](NJF.md#njf-04)
- [NJF-01](NJF.md#njf-01)



**References:**

_None_



**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_


---

### WFJ-02 

The service checks the well-formedness of strings.


**Supported Requests:**

- [JLEX-01](JLEX.md#jlex-01)

**Supporting Items:**

- [NJF-07](NJF.md#njf-07)



**References:**

_None_



**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_


---

### WFJ-03 

The service checks the well-formedness of numbers.


**Supported Requests:**

- [JLEX-01](JLEX.md#jlex-01)

**Supporting Items:**

- [NJF-08](NJF.md#njf-08)



**References:**

_None_



**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_


---

### WFJ-04 

The service checks the well-formedness of array.


**Supported Requests:**

- [JLEX-01](JLEX.md#jlex-01)

**Supporting Items:**

- [NJF-05](NJF.md#njf-05)



**References:**

_None_



**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_


---

### WFJ-05 

The service checks the well-formedness of objects.


**Supported Requests:**

- [JLEX-01](JLEX.md#jlex-01)

**Supporting Items:**

- [NJF-06](NJF.md#njf-06)
- [NJF-13](NJF.md#njf-13)



**References:**

_None_



**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_


---

### WFJ-06 

The service checks that a JSON value must be an object, array, number, or string, or one of the lowercase literal names false, null, or true


**Supported Requests:**

- [JLEX-01](JLEX.md#jlex-01)

**Supporting Items:**

_None_



**References:**

- `function: [basic_json::accept]
(include/nlohmann/json.hpp)`


	- Description: the public interface of the `accept`-functionality of nlohmann/json for single inputs


```cpp
static bool accept(InputType&& i,
                   const bool ignore_comments = false)
{
    return parser(detail::input_adapter(std::forward&lt;InputType&gt;(i)), nullptr, false, ignore_comments).accept(true);
}

```


- `function: [basic_json::accept]
(include/nlohmann/json.hpp)`


	- Description: the public interface of the `accept`-functionality of nlohmann/json for iterator inputs


```cpp
static bool accept(IteratorType first, IteratorType last,
                   const bool ignore_comments = false)
{
    return parser(detail::input_adapter(std::move(first), std::move(last)), nullptr, false, ignore_comments).accept(true);
}

```


- `function: [basic_json::accept]
(include/nlohmann/json.hpp)`


	- Description: the public interface of the `accept`-functionality of nlohmann/json for input buffer


```cpp
JSON_HEDLEY_DEPRECATED_FOR(3.8.0, accept(ptr, ptr + len))
static bool accept(detail::span_input_adapter&& i,
                   const bool ignore_comments = false)
{
    return parser(i.get(), nullptr, false, ignore_comments).accept(true);
}

```


- `function: [parser::accept]
(include/nlohmann/detail/input/parser.hpp)`


	- Description: the internal `accept`-functionality called by basic_json::accept


```cpp
bool accept(const bool strict = true)
{
    json_sax_acceptor&lt;BasicJsonType&gt; sax_acceptor;
    return sax_parse(&sax_acceptor, strict);
}

```


- `function: [parser::sax_parse]
(include/nlohmann/detail/input/parser.hpp)`


	- Description: called by parser::accept


```cpp
bool sax_parse(SAX* sax, const bool strict = true)
{
    (void)detail::is_sax_static_asserts&lt;SAX, BasicJsonType&gt; {};
    const bool result = sax_parse_internal(sax);

    // strict mode: next byte must be EOF
    if (result && strict && (get_token() != token_type::end_of_input))
    {
        return sax-&gt;parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_of_input, "value"), nullptr));
    }

    return result;
}

```


- `function: [parser::sax_parse_internal]
(include/nlohmann/detail/input/parser.hpp)`


	- Description: called by parser::sax_parse


```cpp
bool sax_parse_internal(SAX* sax)
{
    // stack to remember the hierarchy of structured values we are parsing
    // true = array; false = object
    std::vector&lt;bool&gt; states;
    // value to avoid a goto (see comment where set to true)
    bool skip_to_state_evaluation = false;

    while (true)
    {
        if (!skip_to_state_evaluation)
        {
            // invariant: get_token() was called before each iteration
            switch (last_token)
            {
                case token_type::begin_object:
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_object(detail::unknown_size())))
                    {
                        return false;
                    }

                    // closing } -&gt; we are done
                    if (get_token() == token_type::end_object)
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_object()))
                        {
                            return false;
                        }
                        break;
                    }

                    // parse key
                    if (JSON_HEDLEY_UNLIKELY(last_token != token_type::value_string))
                    {
                        return sax-&gt;parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
                    }
                    if (JSON_HEDLEY_UNLIKELY(!sax-&gt;key(m_lexer.get_string())))
                    {
                        return false;
                    }

                    // parse separator (:)
                    if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
                    {
                        return sax-&gt;parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
                    }

                    // remember we are now inside an object
                    states.push_back(false);

                    // parse values
                    get_token();
                    continue;
                }

                case token_type::begin_array:
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax-&gt;start_array(detail::unknown_size())))
                    {
                        return false;
                    }

                    // closing ] -&gt; we are done
                    if (get_token() == token_type::end_array)
                    {
                        if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_array()))
                        {
                            return false;
                        }
                        break;
                    }

                    // remember we are now inside an array
                    states.push_back(true);

                    // parse values (no need to call get_token)
                    continue;
                }

                case token_type::value_float:
                {
                    const auto res = m_lexer.get_number_float();

                    if (JSON_HEDLEY_UNLIKELY(!std::isfinite(res)))
                    {
                        return sax-&gt;parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                out_of_range::create(406, concat("number overflow parsing '", m_lexer.get_token_string(), '\''), nullptr));
                    }

                    if (JSON_HEDLEY_UNLIKELY(!sax-&gt;number_float(res, m_lexer.get_string())))
                    {
                        return false;
                    }

                    break;
                }

                case token_type::literal_false:
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax-&gt;boolean(false)))
                    {
                        return false;
                    }
                    break;
                }

                case token_type::literal_null:
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax-&gt;null()))
                    {
                        return false;
                    }
                    break;
                }

                case token_type::literal_true:
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax-&gt;boolean(true)))
                    {
                        return false;
                    }
                    break;
                }

                case token_type::value_integer:
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax-&gt;number_integer(m_lexer.get_number_integer())))
                    {
                        return false;
                    }
                    break;
                }

                case token_type::value_string:
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax-&gt;string(m_lexer.get_string())))
                    {
                        return false;
                    }
                    break;
                }

                case token_type::value_unsigned:
                {
                    if (JSON_HEDLEY_UNLIKELY(!sax-&gt;number_unsigned(m_lexer.get_number_unsigned())))
                    {
                        return false;
                    }
                    break;
                }

                case token_type::parse_error:
                {
                    // using "uninitialized" to avoid "expected" message
                    return sax-&gt;parse_error(m_lexer.get_position(),
                                            m_lexer.get_token_string(),
                                            parse_error::create(101, m_lexer.get_position(), exception_message(token_type::uninitialized, "value"), nullptr));
                }
                case token_type::end_of_input:
                {
                    if (JSON_HEDLEY_UNLIKELY(m_lexer.get_position().chars_read_total == 1))
                    {
                        return sax-&gt;parse_error(m_lexer.get_position(),
                                                m_lexer.get_token_string(),
                                                parse_error::create(101, m_lexer.get_position(),
                                                        "attempting to parse an empty input; check that your input string or stream contains the expected JSON", nullptr));
                    }

                    return sax-&gt;parse_error(m_lexer.get_position(),
                                            m_lexer.get_token_string(),
                                            parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), nullptr));
                }
                case token_type::uninitialized:
                case token_type::end_array:
                case token_type::end_object:
                case token_type::name_separator:
                case token_type::value_separator:
                case token_type::literal_or_value:
                default: // the last token was unexpected
                {
                    return sax-&gt;parse_error(m_lexer.get_position(),
                                            m_lexer.get_token_string(),
                                            parse_error::create(101, m_lexer.get_position(), exception_message(token_type::literal_or_value, "value"), nullptr));
                }
            }
        }
        else
        {
            skip_to_state_evaluation = false;
        }

        // we reached this line after we successfully parsed a value
        if (states.empty())
        {
            // empty stack: we reached the end of the hierarchy: done
            return true;
        }

        if (states.back())  // array
        {
            // comma -&gt; next value
            if (get_token() == token_type::value_separator)
            {
                // parse a new value
                get_token();
                continue;
            }

            // closing ]
            if (JSON_HEDLEY_LIKELY(last_token == token_type::end_array))
            {
                if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_array()))
                {
                    return false;
                }

                // We are done with this array. Before we can parse a
                // new value, we need to evaluate the new state first.
                // By setting skip_to_state_evaluation to false, we
                // are effectively jumping to the beginning of this if.
                JSON_ASSERT(!states.empty());
                states.pop_back();
                skip_to_state_evaluation = true;
                continue;
            }

            return sax-&gt;parse_error(m_lexer.get_position(),
                                    m_lexer.get_token_string(),
                                    parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_array, "array"), nullptr));
        }

        // states.back() is false -&gt; object

        // comma -&gt; next value
        if (get_token() == token_type::value_separator)
        {
            // parse key
            if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::value_string))
            {
                return sax-&gt;parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(), exception_message(token_type::value_string, "object key"), nullptr));
            }

            if (JSON_HEDLEY_UNLIKELY(!sax-&gt;key(m_lexer.get_string())))
            {
                return false;
            }

            // parse separator (:)
            if (JSON_HEDLEY_UNLIKELY(get_token() != token_type::name_separator))
            {
                return sax-&gt;parse_error(m_lexer.get_position(),
                                        m_lexer.get_token_string(),
                                        parse_error::create(101, m_lexer.get_position(), exception_message(token_type::name_separator, "object separator"), nullptr));
            }

            // parse values
            get_token();
            continue;
        }

        // closing }
        if (JSON_HEDLEY_LIKELY(last_token == token_type::end_object))
        {
            if (JSON_HEDLEY_UNLIKELY(!sax-&gt;end_object()))
            {
                return false;
            }

            // We are done with this object. Before we can parse a
            // new value, we need to evaluate the new state first.
            // By setting skip_to_state_evaluation to false, we
            // are effectively jumping to the beginning of this if.
            JSON_ASSERT(!states.empty());
            states.pop_back();
            skip_to_state_evaluation = true;
            continue;
        }

        return sax-&gt;parse_error(m_lexer.get_position(),
                                m_lexer.get_token_string(),
                                parse_error::create(101, m_lexer.get_position(), exception_message(token_type::end_object, "object"), nullptr));
    }
}

```


- `function: [lexer::scan]
(include/nlohmann/detail/input/lexer.hpp)`


	- Description: scans input, called in parser::sax_parse_internal


```cpp
token_type scan()
{
    // initially, skip the BOM
    if (position.chars_read_total == 0 && !skip_bom())
    {
        error_message = "invalid BOM; must be 0xEF 0xBB 0xBF if given";
        return token_type::parse_error;
    }

    // read next character and ignore whitespace
    skip_whitespace();

    // ignore comments
    while (ignore_comments && current == '/')
    {
        if (!scan_comment())
        {
            return token_type::parse_error;
        }

        // skip following whitespace
        skip_whitespace();
    }

    switch (current)
    {
        // structural characters
        case '[':
            return token_type::begin_array;
        case ']':
            return token_type::end_array;
        case '{':
            return token_type::begin_object;
        case '}':
            return token_type::end_object;
        case ':':
            return token_type::name_separator;
        case ',':
            return token_type::value_separator;

        // literals
        case 't':
        {
            std::array&lt;char_type, 4&gt; true_literal = {{static_cast&lt;char_type&gt;('t'), static_cast&lt;char_type&gt;('r'), static_cast&lt;char_type&gt;('u'), static_cast&lt;char_type&gt;('e')}};
            return scan_literal(true_literal.data(), true_literal.size(), token_type::literal_true);
        }
        case 'f':
        {
            std::array&lt;char_type, 5&gt; false_literal = {{static_cast&lt;char_type&gt;('f'), static_cast&lt;char_type&gt;('a'), static_cast&lt;char_type&gt;('l'), static_cast&lt;char_type&gt;('s'), static_cast&lt;char_type&gt;('e')}};
            return scan_literal(false_literal.data(), false_literal.size(), token_type::literal_false);
        }
        case 'n':
        {
            std::array&lt;char_type, 4&gt; null_literal = {{static_cast&lt;char_type&gt;('n'), static_cast&lt;char_type&gt;('u'), static_cast&lt;char_type&gt;('l'), static_cast&lt;char_type&gt;('l')}};
            return scan_literal(null_literal.data(), null_literal.size(), token_type::literal_null);
        }

        // string
        case '\"':
            return scan_string();

        // number
        case '-':
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            return scan_number();

        // end of input (the null byte is needed when parsing from
        // string literals)
        case '\0':
        case char_traits&lt;char_type&gt;::eof():
            return token_type::end_of_input;

        // error
        default:
            error_message = "invalid literal";
            return token_type::parse_error;
    }
}

```





**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_


---

### WFJ-07 

The service checks that JSON is only serialized using UTF-8.


**Supported Requests:**

- [JLEX-01](JLEX.md#jlex-01)

**Supporting Items:**

- [NJF-12](NJF.md#njf-12)



**References:**

_None_



**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_


---

### WFJ-08 

The service ignores byte order marks.


**Supported Requests:**

- [JLEX-01](JLEX.md#jlex-01)

**Supporting Items:**

- [NJF-14](NJF.md#njf-14)



**References:**

_None_



**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_
