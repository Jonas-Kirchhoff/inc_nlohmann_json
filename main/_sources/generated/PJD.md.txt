
### PJD-01 

The service provides implementations that parses JSON texts, which ignores the presence of a byte order mark rather than treating it as an error.


**Supported Requests:**

- [JLEX-02](JLEX.md#jlex-02)

**Supporting Items:**

- [NPF-01](NPF.md#npf-01)



**References:**

_None_



**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_


---

### PJD-02 

The service transforms a JSON text into a C++ representation using C++ containers (for arrays and objects) and primitive datatypes (for strings, numbers, boolean, null).


**Supported Requests:**

- [PJD-03](PJD.md#pjd-03)

**Supporting Items:**

_None_



**References:**

_None_



**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_


---

### PJD-03 

The service parses all texts that conform to the JSON grammar.


**Supported Requests:**

- [JLEX-02](JLEX.md#jlex-02)

**Supporting Items:**

- [AOU-21](AOU.md#aou-21)
- [AOU-05](AOU.md#aou-05)
- [NPF-02](NPF.md#npf-02)
- [NPF-04](NPF.md#npf-04)
- [NPF-05](NPF.md#npf-05)
- [NPF-06](NPF.md#npf-06)
- [NPF-07](NPF.md#npf-07)
- [NPF-03](NPF.md#npf-03)
- [PJD-02](PJD.md#pjd-02)



**References:**

_None_



**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_


---

### PJD-04 

The service correctly parses 64-bit integers (exceeding the range defined in RFC8259).


**Supported Requests:**


**Supporting Items:**

_None_



**References:**

- `cpp-test: [parser class - core;parse;number;integers]
(TSF/tests/unit-class_parser_core.cpp)`


```cpp
SECTION("integers")
{
    SECTION("without exponent")
    {
        CHECK(parser_helper("-128") == json(-128));
        CHECK(parser_helper("-0") == json(-0));
        CHECK(parser_helper("0") == json(0));
        CHECK(parser_helper("128") == json(128));
    }

    SECTION("with exponent")
    {
        CHECK(parser_helper("0e1") == json(0e1));
        CHECK(parser_helper("0E1") == json(0e1));

        CHECK(parser_helper("10000E-4") == json(10000e-4));
        CHECK(parser_helper("10000E-3") == json(10000e-3));
        CHECK(parser_helper("10000E-2") == json(10000e-2));
        CHECK(parser_helper("10000E-1") == json(10000e-1));
        CHECK(parser_helper("10000E0") == json(10000e0));
        CHECK(parser_helper("10000E1") == json(10000e1));
        CHECK(parser_helper("10000E2") == json(10000e2));
        CHECK(parser_helper("10000E3") == json(10000e3));
        CHECK(parser_helper("10000E4") == json(10000e4));

        CHECK(parser_helper("10000e-4") == json(10000e-4));
        CHECK(parser_helper("10000e-3") == json(10000e-3));
        CHECK(parser_helper("10000e-2") == json(10000e-2));
        CHECK(parser_helper("10000e-1") == json(10000e-1));
        CHECK(parser_helper("10000e0") == json(10000e0));
        CHECK(parser_helper("10000e1") == json(10000e1));
        CHECK(parser_helper("10000e2") == json(10000e2));
        CHECK(parser_helper("10000e3") == json(10000e3));
        CHECK(parser_helper("10000e4") == json(10000e4));

        CHECK(parser_helper("-0e1") == json(-0e1));
        CHECK(parser_helper("-0E1") == json(-0e1));
        CHECK(parser_helper("-0E123") == json(-0e123));

        // numbers after exponent
        CHECK(parser_helper("10E0") == json(10e0));
        CHECK(parser_helper("10E1") == json(10e1));
        CHECK(parser_helper("10E2") == json(10e2));
        CHECK(parser_helper("10E3") == json(10e3));
        CHECK(parser_helper("10E4") == json(10e4));
        CHECK(parser_helper("10E5") == json(10e5));
        CHECK(parser_helper("10E6") == json(10e6));
        CHECK(parser_helper("10E7") == json(10e7));
        CHECK(parser_helper("10E8") == json(10e8));
        CHECK(parser_helper("10E9") == json(10e9));
        CHECK(parser_helper("10E+0") == json(10e0));
        CHECK(parser_helper("10E+1") == json(10e1));
        CHECK(parser_helper("10E+2") == json(10e2));
        CHECK(parser_helper("10E+3") == json(10e3));
        CHECK(parser_helper("10E+4") == json(10e4));
        CHECK(parser_helper("10E+5") == json(10e5));
        CHECK(parser_helper("10E+6") == json(10e6));
        CHECK(parser_helper("10E+7") == json(10e7));
        CHECK(parser_helper("10E+8") == json(10e8));
        CHECK(parser_helper("10E+9") == json(10e9));
        CHECK(parser_helper("10E-1") == json(10e-1));
        CHECK(parser_helper("10E-2") == json(10e-2));
        CHECK(parser_helper("10E-3") == json(10e-3));
        CHECK(parser_helper("10E-4") == json(10e-4));
        CHECK(parser_helper("10E-5") == json(10e-5));
        CHECK(parser_helper("10E-6") == json(10e-6));
        CHECK(parser_helper("10E-7") == json(10e-7));
        CHECK(parser_helper("10E-8") == json(10e-8));
        CHECK(parser_helper("10E-9") == json(10e-9));
    }

    SECTION("edge cases")
    {
        // From RFC8259, Section 6:
        // Note that when such software is used, numbers that are
        // integers and are in the range [-(2**53)+1, (2**53)-1]
        // are interoperable in the sense that implementations will
        // agree exactly on their numeric values.

        // -(2**53)+1
        CHECK(parser_helper("-9007199254740991").get&lt;int64_t&gt;() == -9007199254740991);
        // (2**53)-1
        CHECK(parser_helper("9007199254740991").get&lt;int64_t&gt;() == 9007199254740991);
    }

    SECTION("over the edge cases")  // issue #178 - Integer conversion to unsigned (incorrect handling of 64-bit integers)
    {
        // While RFC8259, Section 6 specifies a preference for support
        // for ranges in range of IEEE 754-2008 binary64 (double precision)
        // this does not accommodate 64-bit integers without loss of accuracy.
        // As 64-bit integers are now widely used in software, it is desirable
        // to expand support to the full 64 bit (signed and unsigned) range
        // i.e. -(2**63) -&gt; (2**64)-1.

        // -(2**63)    ** Note: compilers see negative literals as negated positive numbers (hence the -1))
        CHECK(parser_helper("-9223372036854775808").get&lt;int64_t&gt;() == -9223372036854775807 - 1);
        // (2**63)-1
        CHECK(parser_helper("9223372036854775807").get&lt;int64_t&gt;() == 9223372036854775807);
        // (2**64)-1
        CHECK(parser_helper("18446744073709551615").get&lt;uint64_t&gt;() == 18446744073709551615u);
    }
}

```





**Fallacies:**

_None_

**Graph:**

_No Historic Data Found_
